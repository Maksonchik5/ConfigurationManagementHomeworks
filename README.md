```markdown
# Задание №1

Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу эмулятора как можно более похожей на сеанс shell в UNIX-подобной ОС. Эмулятор должен запускаться из реальной командной строки, а файл с виртуальной файловой системой не нужно распаковывать у пользователя.

Эмулятор принимает образ виртуальной файловой системы в виде файла формата `tar`. Эмулятор должен работать в режиме CLI.

Конфигурационный файл имеет формат `json` и содержит:
- Имя пользователя для показа в приглашении к вводу.
- Путь к архиву виртуальной файловой системы.
- Путь к стартовому скрипту.

Стартовый скрипт служит для начального выполнения заданного списка команд из файла.

Необходимо поддержать в эмуляторе команды `ls`, `cd` и `exit`, а также следующие команды:
1. `clear`
2. `cp`

Все функции эмулятора должны быть покрыты тестами, а для каждой из поддерживаемых команд необходимо написать 2 теста.

Результат работы программы
![image](https://github.com/user-attachments/assets/6638ddd9-2c1e-47b7-be1d-716bb7774744)


# Задание №2

Разработать инструмент командной строки для визуализации графа зависимостей, включая транзитивные зависимости. Сторонние средства для получения зависимостей использовать нельзя.

Зависимости определяются по имени пакета ОС Ubuntu (apt). Для описания графа зависимостей используется представление `Mermaid`. Визуализатор должен выводить результат в виде сообщения об успешном выполнении и сохранять граф в файле формата `png`.

Конфигурационный файл имеет формат `yaml` и содержит:
- Путь к программе для визуализации графов.
- Имя анализируемого пакета.
- Путь к файлу с изображением графа зависимостей.
- Максимальная глубина анализа зависимостей.

Все функции визуализатора зависимостей должны быть покрыты тестами.

# Задание №3

Разработать инструмент командной строки для учебного конфигурационного языка, синтаксис которого приведен далее. Этот инструмент преобразует текст из входного формата в выходной. Синтаксические ошибки выявляются с выдачей сообщений.

Входной текст на учебном конфигурационном языке принимается из файла, путь к которому задан ключом командной строки. Выходной текст на языке `toml` попадает в файл, путь к которому задан ключом командной строки.

Многострочные комментарии:


Это многострочный 
комментарий 


Словари:

имя = значение; 
имя = значение; 
имя = значение; 
...


Имена:

[a-z]+


Значения:
- Числа.
- Строки.
- Словари.

Строки:

"Это строка"


Объявление константы на этапе трансляции:

имя = значение


Вычисление константы на этапе трансляции:

.[имя].


Результатом вычисления константного выражения является значение.

Все конструкции учебного конфигурационного языка (с учетом их возможной вложенности) должны быть покрыты тестами. Необходимо показать 3 примера описания конфигураций из разных предметных областей.

# Задание №4

Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ). Система команд УВМ представлена далее.

Для ассемблера необходимо разработать читаемое представление команд УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к которой задается из командной строки. Результатом работы ассемблера является бинарный файл в виде последовательности байт, путь к которому задается из командной строки. Дополнительный ключ командной строки задает путь к файлу логу, в котором хранятся ассемблированные инструкции в духе списков `ключ=значение`, как в приведенных далее тестах.

Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон также указывается из командной строки.

Форматом для файла-лога и файла-результата является `json`.

Необходимо реализовать приведенные тесты для всех команд, а также написать и отладить тестовую программу.

## Загрузка константы
- **A** - Биты 0—3
- **B** - Биты 4—32
- Размер команды: 5 байт. Операнд: поле B. Результат: регистр-аккумулятор.

**Тест (A=5, B=148):**

0x45, 0x09, 0x00, 0x00, 0x00


## Чтение значения из памяти
- **A** - Биты 0—3
- **B** - Биты 4—9
- Размер команды: 5 байт. Операнд: значение в памяти по адресу, которым является сумма адреса (регистр-аккумулятор) и смещения (поле B). Результат: регистр-аккумулятор.

**Тест (A=15, B=20):**

0x4F, 0x01, 0x00, 0x00, 0x00


## Запись значения в память
- **A** - Биты 0—3
- **B** - Биты 4—16
- Размер команды: 5 байт. Операнд: регистр-аккумулятор. Результат: значение в памяти по адресу, которым является поле B.

**Тест (A=12, B=547):**

0x3C, 0x22, 0x00, 0x00, 0x00


## Бинарная операция: умножение
- **A** - Биты 0—3
- **B** - Биты 4—16
- Размер команды: 5 байт. Первый операнд: регистр-аккумулятор. Второй операнд: значение в памяти по адресу, которым является поле B. Результат: регистр-аккумулятор.

**Тест (A=11, B=762):**

0xAB, 0x2F, 0x00, 0x00, 0x00


## Тестовая программа
```
Выполнить поэлементно операцию умножение над двумя векторами длины 5. Результат записать во второй вектор.

